# Treetop (http://treetop.rubyforge.org/) grammar for package definitions from
# the early days, which we're calling v0.  Since we're making a slight
# incompatibility in asset locations, v1 is being used as a "gentle
# introduction" to the concept of multiple grammar versions.  Since v0 and v1
# are so close, this is everything from the early grammar other than the asset
# location.

# The difference between v0 and v1 is that v1 allows more characters in asset
# paths.

# Some aspects of this grammar are significantly dumber than they could be
# because:
#
#   * We want to treat statements as identically as possible to their
#     command-line equivalents.
#   * Treetop parse errors are pretty inscrutable at times and we can make
#     error messages clearer by validating a lot of the terminals ourselves.

require 'treetop'

module Fig
  module Grammar
    grammar V0Ish
      rule package
        optional_ws grammar_version:grammar_version? ws* statements:(package_statement*) optional_ws {
          def to_package(directory, build_state)
            return build_state.new_package_statement(
              directory, grammar_version, statements
            )
          end
        }
      end

      rule package_statement
        archive / resource / retrieve / config
      end

      rule archive
        statement_start:'archive' ws+ location:asset_location {
          def to_package_statement(build_state)
            return build_state.new_asset_statement(
              Statement::Archive, statement_start, location.location
            )
          end
        }
      end

      rule resource
        statement_start:'resource' ws+ location:asset_location {
          def to_package_statement(build_state)
            return build_state.new_asset_statement(
              Statement::Resource, statement_start, location.location
            )
          end
        }
      end

      rule retrieve
        statement_start:'retrieve' ws+ var:environment_variable_name '->' path:retrieve_path ws+ {
          def to_package_statement(build_state)
            return build_state.new_retrieve_statement(statement_start, var, path)
          end
        }
      end

      rule retrieve_path
        [a-zA-Z0-9_/.\[\]-]+
      end

      rule config
        statement_start:'config' ws+ config_name ws+ statements:config_statement* 'end' ws+ {
          def to_package_statement(build_state)
            return build_state.new_configuration_statement(
              statement_start, config_name, statements
            )
          end
        }
      end

      rule config_name
        [a-zA-Z0-9_.-]+
      end

      rule config_statement
        override / include / command / path / set
      end

      rule include
        statement_start:'include' ws+ descriptor_string ws+ {
          def to_config_statement(build_state)
            return build_state.new_include_statement(
              statement_start, descriptor_string
            )
          end
        }
      end

      rule override
        statement_start:'override' ws+ descriptor_string ws+ {
          def to_config_statement(build_state)
            return build_state.new_override_statement(
              statement_start, descriptor_string
            )
          end
        }
      end

      rule path
        statement_start:('add' / 'append' / 'path') ws+ name_value:[\S]+ ws+ {
          def to_config_statement(build_state)
            return build_state.new_environment_variable_statement(
              Statement::Path, statement_start, name_value
            )
          end
        }
      end

      rule environment_variable_name
        [a-zA-Z0-9_]+
      end

      rule set
        statement_start:'set' ws+ name_value:[\S]+ ws+ {
          def to_config_statement(build_state)
            return build_state.new_environment_variable_statement(
              Statement::Set, statement_start, name_value
            )
          end
        }
      end

      rule command
        statement_start:'command' ws+ string ws+ {
          def to_config_statement(build_state)
            return build_state.new_command_statement(statement_start, string)
          end
        }
      end

      rule string
        '"' value:[^"]* '"'
      end

      rule descriptor_string
        [\S]+
      end
    end
  end
end
