# Treetop (http://treetop.rubyforge.org/) grammar for package definitions.

require 'fig/package'
require 'fig/packagedescriptor'
require 'fig/parser'
require 'fig/statement/archive'
require 'fig/statement/command'
require 'fig/statement/configuration'
require 'fig/statement/include'
require 'fig/statement/override'
require 'fig/statement/path'
require 'fig/statement/resource'
require 'fig/statement/retrieve'
require 'fig/statement/set'

module Fig
  grammar Fig
    rule package
      optional_ws statements:(package_statement*) optional_ws {
        def to_package(directory, build_state)
          Package.new(
            build_state.descriptor.name,
            build_state.descriptor.version,
            directory,
            statements.elements.map do
              |statement|
              statement.to_package_statement(build_state)
            end
          )
        end
      }
    end

    rule package_statement
      archive / resource / retrieve / config
    end

    rule archive
      statement_start:"archive" ws resource_url {
        def to_package_statement(build_state)
          Statement::Archive.new(
            build_state.node_location(statement_start),
            build_state.source_description,
            resource_url.value.text_value
          )
        end
      }
    end

    rule resource
      statement_start:"resource" ws resource_url {
        def to_package_statement(build_state)
          Statement::Resource.new(
            build_state.node_location(statement_start),
            build_state.source_description,
            resource_url.value.text_value
          )
        end
      }
    end

    rule retrieve
      statement_start:"retrieve" ws var:environment_variable_name "->" path:retrieve_path ws {
        def to_package_statement(build_state)
          Statement::Retrieve.new(
            build_state.node_location(statement_start),
            build_state.source_description,
            var.text_value,
            path.text_value
          )
        end
      }
    end

    rule retrieve_path
      [a-zA-Z0-9_/.\[\]-]+
    end

    rule config
      statement_start:"config" ws config_name ws statements:config_statement* "end" ws {
        def to_package_statement(build_state)
          Statement::Configuration.new(
            build_state.node_location(statement_start),
            build_state.source_description,
            config_name.text_value,
            statements.elements.map do
              |statement|
              statement.to_config_statement(build_state)
            end
          )
        end
      }
    end

    rule config_name
      [a-zA-Z0-9_.-]+
    end

    rule config_statement
      override / include / command / path / set
    end

    rule include
      statement_start:"include" ws descriptor_string ws {
        def to_config_statement(build_state)
          include_descriptor =
            Statement::Include.parse_descriptor(
              descriptor_string.text_value.strip,
              :source_description =>
                build_state.node_location_description(descriptor_string),
              :validation_context => ' for an include statement'
            )

          Statement::Include.new(
            build_state.node_location(statement_start),
            build_state.source_description,
            include_descriptor,
            build_state.descriptor
          )
        end
      }
    end

    rule override
      statement_start:"override" ws descriptor_string ws {
        def to_config_statement(build_state)
          descriptor =
            Statement::Override.parse_descriptor(
              descriptor_string.text_value.strip,
              :source_description =>
                build_state.node_location_description(descriptor_string),
              :validation_context => ' for an override statement'
            )

          return Statement::Override.new(
            build_state.node_location(statement_start),
            build_state.source_description,
            descriptor.name,
            descriptor.version
          )
        end
      }
    end

    rule path
      statement_start:("add" / "append" / "path") ws name:environment_variable_name "=" value:path_value ws {
        def to_config_statement(build_state)
          Statement::Path.new(
            build_state.node_location(statement_start),
            build_state.source_description,
            name.text_value,
            value.text_value
          )
        end
      }
    end

    rule environment_variable_name
      [a-zA-Z0-9_]+
    end

    rule path_value
      # Characters blocked in the value:
      #    ;:     - Windows/*nix path separators
      #    "<>|   - Characters not allowed in filenames on Windows
      #    \s     - Necessary for the "ws" token to work
      [^;:"<>|\s]+
    end

    rule set
      statement_start:"set" ws name:environment_variable_name "=" value:set_value ws {
        def to_config_statement(build_state)
          Statement::Set.new(
            build_state.node_location(statement_start),
            build_state.source_description,
            name.text_value,
            value.text_value
          )
        end
      }
    end

    rule set_value
      [\S]*
    end

    rule command
      statement_start:"command" ws string {
        def to_config_statement(build_state)
          Statement::Command.new(
            build_state.node_location(statement_start),
            build_state.source_description,
            string.value.text_value
          )
        end
      }
    end

    rule string
      '"' value:(!'"' . )* '"' ws
    end

    rule descriptor_string
      [\S]+
    end

    rule package_name
      [a-zA-Z0-9_.-]+
    end

    rule version_name
      [a-zA-Z0-9_.-]+
    end

    rule resource_url
      # Unquoted allows globbing for files, quoted does not.
      #
      # Unquoted, anything but:
      #    @      - To allow for package substitution
      #    "<>|   - Characters not allowed in filenames on Windows
      #    \s     - Necessary for the "ws" token to work
      (value:[^@"<>|\s]+ ws)

      # Quoted, anything but:
      #    @        - To allow for package substitution
      #    "<>|     - Characters not allowed in filenames on Windows
      #    *?\[\]{} - Characters significant to Dir.glob()
      #    \s       - We just don't want these. :]  (May need to allow space.)
      / ('"' value:[^@"<>|*?\[\]{}\s]+ '"' ws)
    end

    rule ws
      [ \n\r\t]+
    end

    rule optional_ws
      [ \n\r\t]*
    end
  end
end
