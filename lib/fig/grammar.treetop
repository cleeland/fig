require 'fig/package'
require 'fig/packagedescriptor'
require 'fig/parser'
require 'fig/statement/archive'
require 'fig/statement/command'
require 'fig/statement/configuration'
require 'fig/statement/include'
require 'fig/statement/override'
require 'fig/statement/path'
require 'fig/statement/publish'
require 'fig/statement/resource'
require 'fig/statement/retrieve'
require 'fig/statement/set'

module Fig

grammar Fig
  rule package
    optional_ws statements:(package_statement*) optional_ws {
      def to_package(descriptor, directory)
        Package.new(
          descriptor.name,
          descriptor.version,
          directory,
          statements.elements.map do
            |statement|
            statement.to_package_statement(descriptor)
          end
        )
      end
    }
  end

  rule package_statement
    archive / resource / retrieve / config
  end

  rule archive
    statement_start:"archive" ws url {
      def to_package_statement(descriptor)
        Statement::Archive.new(
          Parser.node_location(statement_start), url.value.text_value
        )
      end
    }
  end

  rule resource
    statement_start:"resource" ws url {
      def to_package_statement(descriptor)
        Statement::Resource.new(
          Parser.node_location(statement_start), url.value.text_value
        )
      end
    }
  end

  rule retrieve
    statement_start:"retrieve" ws var:retrieve_variable "->" path:retrieve_path ws {
      def to_package_statement(descriptor)
        Statement::Retrieve.new(
          Parser.node_location(statement_start),
          var.text_value,
          path.text_value
        )
      end
    }
  end

  rule retrieve_variable
    [@a-zA-Z0-9/._]+
  end

  rule retrieve_path
    [a-zA-Z0-9_/.\[\]-]+
  end

  rule config
    statement_start:"config" ws config_name ws statements:config_statement* "end" ws {
      def to_package_statement(descriptor)
        Statement::Configuration.new(
          Parser.node_location(statement_start),
          config_name.text_value,
          statements.elements.map do
            |statement|
            statement.to_config_statement(descriptor)
          end
        )
      end
    }
  end

  rule config_statement
    include / command / path / set
  end

  rule include
    statement_start:"include" ws descriptor overrides:(override*) {
      def to_config_statement(containing_package_descriptor)
        Statement::Include.new(
          Parser.node_location(statement_start),
          PackageDescriptor.parse(descriptor.text_value.strip),
          overrides.elements.map{ |e| e.to_override },
          containing_package_descriptor
        )
      end
    }
  end

  rule override
    statement_start:"override" ws package_name "/" version_name ws {
      def to_override
        return Statement::Override.new(
          Parser.node_location(statement_start),
          package_name.text_value,
          version_name.text_value
        )
      end
    }
  end

  rule path
    statement_start:("append" / "path" / "add") ws name:path_name "=" value:path_value ws {
      def to_config_statement(descriptor)
        Statement::Path.new(
          Parser.node_location(statement_start),
          name.text_value,
          value.text_value
        )
      end
    }
  end

  rule path_name
    [a-zA-Z0-9_]+
  end

  rule path_value
    [@a-zA-Z0-9/\\._-]+
  end

  rule set
    statement_start:"set" ws name:set_name "=" value:set_value ws {
      def to_config_statement(descriptor)
        Statement::Set.new(
          Parser.node_location(statement_start),
          name.text_value,
          value.text_value
        )
      end
    }
  end

  rule set_name
    [a-zA-Z0-9_]+
  end

  rule set_value
    [@a-zA-Z0-9/\\._-]*
  end

  rule command
    statement_start:"command" ws string {
      def to_config_statement(descriptor)
        Statement::Command.new(
          Parser.node_location(statement_start), string.value.text_value
        )
      end
    }
  end

  rule string
    '"' value:(!'"' . )* '"' ws
  end

  rule descriptor
    ((package:package_name ("/" version:version_name)? (":" config:config_name)? ws) /
    (":" config:config_name ws)) {
      def get_version
        elements.each do |element|
          if element.respond_to?(:version)
            return element.version.text_value
          end
        end
        nil
      end
      def get_config
        return self.config.text_value if self.respond_to?(:config)
        elements.each do |element|
          if element.respond_to?(:config)
            return element.config.text_value
          end
        end
        nil
      end
    }
  end

  rule package_name
    [a-zA-Z0-9.-]+
  end

  rule version_name
    [a-zA-Z0-9_.-]+
  end

  rule config_name
    [a-zA-Z0-9_.-]+
  end

  rule url
    (value:[a-zA-Z0-9:/\\._*-]+ ws) / ('"' value:[a-zA-Z0-9:/\\._-]+ '"' ws)
  end

  rule ws
    [ \n\r\t]+
  end

  rule optional_ws
    [ \n\r\t]*
  end
end

end
