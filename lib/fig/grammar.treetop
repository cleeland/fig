# Treetop (http://treetop.rubyforge.org/) grammar

require 'fig/package'
require 'fig/packagedescriptor'
require 'fig/parser'
require 'fig/statement/archive'
require 'fig/statement/command'
require 'fig/statement/configuration'
require 'fig/statement/include'
require 'fig/statement/override'
require 'fig/statement/path'
require 'fig/statement/publish'
require 'fig/statement/resource'
require 'fig/statement/retrieve'
require 'fig/statement/set'

module Fig
  grammar Fig
    rule package
      optional_ws statements:(package_statement*) optional_ws {
        def to_package(descriptor, directory, source_description)
          Package.new(
            descriptor.name,
            descriptor.version,
            directory,
            statements.elements.map do
              |statement|
              statement.to_package_statement(descriptor, source_description)
            end
          )
        end
      }
    end

    rule package_statement
      archive / resource / retrieve / config
    end

    rule archive
      statement_start:"archive" ws resource_url {
        def to_package_statement(descriptor, source_description)
          Statement::Archive.new(
            Parser.node_location(statement_start),
            source_description,
            resource_url.value.text_value
          )
        end
      }
    end

    rule resource
      statement_start:"resource" ws resource_url {
        def to_package_statement(descriptor, source_description)
          Statement::Resource.new(
            Parser.node_location(statement_start),
            source_description,
            resource_url.value.text_value
          )
        end
      }
    end

    rule retrieve
      statement_start:"retrieve" ws var:retrieve_variable_name "->" path:retrieve_path ws {
        def to_package_statement(descriptor, source_description)
          Statement::Retrieve.new(
            Parser.node_location(statement_start),
            source_description,
            var.text_value,
            path.text_value
          )
        end
      }
    end

    rule retrieve_variable_name
      [@a-zA-Z0-9/._]+
    end

    rule retrieve_path
      [a-zA-Z0-9_/.\[\]-]+
    end

    rule config
      statement_start:"config" ws config_name ws statements:config_statement* "end" ws {
        def to_package_statement(descriptor, source_description)
          Statement::Configuration.new(
            Parser.node_location(statement_start),
            source_description,
            config_name.text_value,
            statements.elements.map do
              |statement|
              statement.to_config_statement(descriptor, source_description)
            end
          )
        end
      }
    end

    rule config_statement
      include / command / path / set
    end

    rule include
      statement_start:"include" ws descriptor overrides:(override*) {
        def to_config_statement(
          containing_package_descriptor, source_description
        )
          Statement::Include.new(
            Parser.node_location(statement_start),
            source_description,
            PackageDescriptor.parse(descriptor.text_value.strip),
            overrides.elements.map{ |e| e.to_override(source_description) },
            containing_package_descriptor
          )
        end
      }
    end

    rule override
      statement_start:"override" ws package_name "/" version_name ws {
        def to_override(source_description)
          return Statement::Override.new(
            Parser.node_location(statement_start),
            source_description,
            package_name.text_value,
            version_name.text_value
          )
        end
      }
    end

    rule path
      statement_start:("append" / "path" / "add") ws name:environment_variable_name "=" value:path_value ws {
        def to_config_statement(descriptor, source_description)
          Statement::Path.new(
            Parser.node_location(statement_start),
            source_description,
            name.text_value,
            value.text_value
          )
        end
      }
    end

    rule environment_variable_name
      [a-zA-Z0-9_]+
    end

    rule path_value
      # Characters blocked in the value:
      #    ;:     - Windows/*nix path separators
      #    "<>|   - Characters not allowed in filenames on Windows
      #    \s     - Necessary for the "ws" token to work
      [^;:"<>|\s]+
    end

    rule set
      statement_start:"set" ws name:environment_variable_name "=" value:set_value ws {
        def to_config_statement(descriptor, source_description)
          Statement::Set.new(
            Parser.node_location(statement_start),
            source_description,
            name.text_value,
            value.text_value
          )
        end
      }
    end

    rule set_value
      [\S]*
    end

    rule command
      statement_start:"command" ws string {
        def to_config_statement(descriptor, source_description)
          Statement::Command.new(
            Parser.node_location(statement_start),
            source_description,
            string.value.text_value
          )
        end
      }
    end

    rule string
      '"' value:(!'"' . )* '"' ws
    end

    rule descriptor
      ((package:package_name ("/" version:version_name)? (":" config:config_name)? ws) /
      (":" config:config_name ws)) {
        def get_version
          elements.each do |element|
            if element.respond_to?(:version)
              return element.version.text_value
            end
          end
          nil
        end
        def get_config
          return self.config.text_value if self.respond_to?(:config)
          elements.each do |element|
            if element.respond_to?(:config)
              return element.config.text_value
            end
          end
          nil
        end
      }
    end

    rule package_name
      [a-zA-Z0-9_.-]+
    end

    rule version_name
      [a-zA-Z0-9_.-]+
    end

    rule config_name
      [a-zA-Z0-9_.-]+
    end

    rule resource_url
      # Unquoted allows globbing for files, quoted does not.
      #
      # Unquoted, anything but:
      #    @      - To allow for package substitution
      #    "<>|   - Characters not allowed in filenames on Windows
      #    \s     - Necessary for the "ws" token to work
      (value:[^@"<>|\s]+ ws)

      # Unquoted, anything but:
      #    @        - To allow for package substitution
      #    "<>|     - Characters not allowed in filenames on Windows
      #    *?\[\]{} - Characters significant to Dir.glob()
      #    \s       - We just don't want these. :]  (May need to allow space.)
      / ('"' value:[^@"<>|*?\[\]{}\s]+ '"' ws)
    end

    rule ws
      [ \n\r\t]+
    end

    rule optional_ws
      [ \n\r\t]*
    end
  end
end
